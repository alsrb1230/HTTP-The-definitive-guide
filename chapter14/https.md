# 14. HTTP 완벽 가이드 : 보안 HTTP

HTTP 보안 기술은 다음과 같은 특성들을 가져야 한다

- 서버 인증
- 클라이언트 인증
- 무결성
- 암호화
- 효율
- 편재성
- 관리상 확장성
- 적응성
- 사회적 생존성


<br />

<aside>
💡  따라서 HTTP 네트워크 통신을 더 안전하게 만들수록 좋다!

</aside>

<br /><br /><br />

# 14.1 HTTPS

HTTP를 안전하게 만드는 방식 중에서 가장 인기 있는 방식!

- URL이 `https://`로 시작
- HTTPS를 사용하면 모든 HTTP 요청 / 응답 데이터는 네트워크로 보내지기 전에 암호화
- HTTP 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작
    - 보안 계층은 **안전 소캣 계층**(`Secure Sockets Layer, SSL`) 혹은 **전송 계층 보안**(`Transport Layer Security, TLS`)를 사용하여 구현
    - SSL, TLS 안에서 인코딩, 디코딩 작업이 일어난다.
    - (+) 이 둘은 매우 비슷하기 때문에 이 책에서는 **둘 모두를 통칭하여 SSL이라고 부릅니다!!**
  
    ![Untitled](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/fe12b093-b5de-4666-a4f0-17f5aa908eae)


<br /><br /><br />

# 14.2 디지털 암호화

SSL과 HTTPS에서 이용되는 암호 인코딩 기법에 대한 간단한 용어 정리

- **암호** : 텍스트를 아무나 읽지 못하도록 암호화하는 알고리즘
- **키** : 암호의 동작을 변경하는 숫자로 된 매개변수
- **대칭키 암호 체계** : 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- **비대칭키 암호 체계** : 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- **공개키 암호법** : 비밀 메세지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- **디지털 서명** : 메세지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- **디지털 인증서** : 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

<br /><br />

## 키가 있는 암호

![Untitled 1](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/b9b3331e-1cd8-42b0-8fd4-ed7fe6677e2c)


<br /><br /><br />

# **14.3 대칭키 암호법**

- 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- 대칭키가 누설된다면 **쉽게 복호화된다.**
- ex) DES, Triple-DES, RC2, RC4

<br /><br /><br />

# **14.4 공개키 암호법**

- 인코딩과 디코딩에 다른 키를 사용하는 알고리즘 (비대칭키 암호법)
- 인코딩 키와 디코딩 키를 각각 Client, Server가 가지고 있다.
- 여러 Client는 하나의 공개키로만 통신이 가능하다. (어차피 서버만 풀 수 있다.)
- **절대 뚫을 수 없지만 느리다.**
- ex) RSA 알고리즘

<br /><br />

## RSA

공개키 비대칭 암호의 과제는 아래 내용을 알고 있다해도 개인 키를 계산할 수 없다는 것

- 공개키
- 네트워크 스누핑을 통해 얻은 암호문의 일부
- 메시지와 그것을 암호화한 암호문(인코더에 임의의 텍스트를 넣고 실행해서 획득)

⇒ **이를 만족하는 공개키 암호 체계 중 유명한 하나가 RSA 알고리즘**

<br /><br />

---

각자의 장단점이 뚜렷하여, **보통은 공개키와 대칭키 방식을 섞어서 사용**한다.

1. 노드들 사이의 안전한 의사소통 채널 수립할때는 ⇒ **공개 키 암호화**
2. 만들어진 채널을 통해 나머지 데이터 교환 ⇒ **대칭 키 암호화**

   
![Untitled 2](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/91e18a43-3358-4549-9870-ee318eee8f1a)


<br /><br /><br />

# 14.5 디지털 서명

디지털 서명 기법은 인터넷 보안 인증서에서 해당 메세지가 위조되거나 변조되지 않았음을 증명해준다.

보통 공개키 (비대칭키)에 의해 생성되며, 개인 키는 오직 소유자만이 알고 있다.

<br /><br />

## 암호 체크섬

디지털 서명은 메세지에 붙어있는 암호 체크섬이다.

- 서명 작성자는 극비 개인키를 본인만 가지고 있기 때문에 오직 본인만이 체크섬을 계산할 수 있다.
- 메세지 위조를 방지한다.
    - 만약 공격자가 송신중인 메세지를 수정하면, 체크섬이 달라진다.
      
![Untitled 3](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/f558e298-bb38-4c8b-9caf-24f25c5a3deb)

<br />

> **체크섬 (Checksum)**
중복 검사의 한 형태이며, 송신된 자료의 무결성을 보호하는 단순한 방법
>

<br /><br /><br />

# 14.6 디지털 인증서

디지털 인증서는 공식적으로 인정된 인증 기관에 의해 서명된 정보의 집합이다.

보통 다음과 같은 정보를 내포한다.

- 대상의 이름 (조직 / 서버)
- 유효 기간
- 인증서 발급자 (누가 보증하는가)
- 인증서 발급자의 디지털 서명
- 대상의 공개 키
  
![Untitled 4](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/6531986c-9831-4255-884f-e9f84cf95be2)


<br /><br />

## 서버 인증을 위한 인증서 사용

1. 사용자가 HTTPS 를 통한 안전한 웹 트랜잭션 시작
    1. 최신 브라우저는 자동으로 ‘접속한 서버’에서 ‘디지털 인증서’를 가져옴
    2. 만약 서버가 인증서 미보유 ⇒ 보안 커넥션 실패
    3. 서버 인증서가 포함하는 필드
        
        ```html
        - 웹 사이트의 이름과 호스트 명
        - 웹 사이트의 공개키
        - 서명 기관의 이름
        - 서명 기관의 서명
        ```
        
2. 브라우저가 인증서를 받으면, 서명 기관을 검사한다
    1. 해당 기관이 공공이 신뢰할만한 서명 기관이라면, 브라우저는 그것의 공개키를 이미 알고 있을 것.
    (보통 브라우저에 여러 서명 기관의 인증서는 미리 설치)
    2. 만약 서명 기관이 모르는 곳이라면, 서명 기관을 신뢰하는지 확인하기 위한 대화상자를 출력
3. ‘디지털 서명’에서 이야기했던 바와 같이, 브라우저가 서명 검증


<br /><br /><br />

# 14. 7 HTTPS 세부사항

HTTPS는 HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것이다. 😓

쉽게 풀어 말하면, 

- HTTPS는 보안 전송 계층을 통해 전송되는 HTTP이다.
- HTTPS는 HTTP 메세지를 TCP로 보내기 전에, SSL(SSL, TLS) 계층으로 보낸다.
  
![Untitled 5](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/fad0c37a-6432-4435-bc3a-ce2f4050707e)


SSL 트래픽은 바이너리 프로토콜이기 때문에, 바이너리 SSL 트래픽을 전송하여 HTTP와는 완전히 다르다.

<br /><br />

## 보안 전송 셋업

1. **암호화 되지 않은 HTTP**
    1. 클라이언트는 웹 서버의 `80` 포트로 TCP 커넥션 열기
    2. 요청 메세지 송신
    3. 응답 메세지 수신
    4. TCP 커넥션 종료
    
2. **암호화 된 HTTPS**
    1. 클라이언트는 웹 서버의 `443` 포트로 TCP 커넥션 열기
    2. **암호법 매개변수와 교환 키를 협상하며 SSL 계층 초기화 (핸드셰이크)**
    3. 요청 메세지 송신 (암호화된 메세지)
    4. 응답 메세지 수신 (암호화된 메세지)
    5. SSL 닫힘
    6. TCP 커넥션 종료
       
![Untitled 6](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/81817c52-ddf1-40b2-ac2c-c1d0e38a86ea)

<br /><br />

## 핸드셰이크

SSL 핸드셰이크의 정확한 과정은 다음과 같다.

- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 세션 키 생성
  
![Untitled 7](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/e07735f5-950c-4f64-8238-ef9b331f3e3b)

<br /><br />

## 서버 인증서

SSL은 서버 인증서를 클라이언트로 전달, 클라이언트 인증서를 서버에 전달하는 상호 인증을 지원하지만 오늘날 클라이언트 인증서는 흔히 쓰이지 않는다. 하지만 서버 인증서는 항상 요구된다. 

서버 인증서에는 다음과 같은 정보들이 포함되어 있다.

- 인증서 일련번호
- 인증서 유효기간
- 사이트의 조직 이름
- 사이트의 DNS 호스트 명
- 사이트의 공개키
- 인증서 발급자 이름
- 인증서 발급자 서명

<br />

다음과 같은 경우에는 클라이언트 인증서가 요구될 때도 있다.

- 회사 설정에서 웹 브라우징을 위해, 보안 이메일을 위해 사용
- 직원들이 정보에 접근하는 것을 제어하기 위한 목적으로 클라이언트 인증서 사용

<br /><br />

## 사이트 인증서 검사

브라우저들은 인증서에 대해 간단하게 기본적인 검사를 하고, 그 결과를 사용자에게 알려준다.

그 수행 단계는 다음과 같다.

1. 날짜 검사
2. 서명자 신뢰도 검사
3. 서명 검사
4. 사이트 신원 검사

<br />

<aside>
💡 SSL은 복잡한 바이너리 프로토콜이다. 
암호 전문가가 아닌 이상 SSL 트래픽을 직접 보내지 말아야 한다.

따라서 상용 혹은 오픈소스 라이브러리를 사용할 수 있다. (ex. `OpenSSL`)

</aside>

<br /><br /><br />

# 14.9 프락시를 통한 보안 트래픽 터널링

if) 만약 클라이언트가 웹 프락시 서버를 사용하고 있고, 
     이 프락시가 클라이언트를 대신해서 서버에 접근한다면

1. 클라이언트가 서버로 보낼 데이터를 서버의 공개키로 암호화
2. 프락시 서버는 HTTP 헤더를 읽을 수 없다!
3. 따라서 어디로 요청을 보내야 하는지 모른다!

해당 문제를 해결하기 위해, 클라이언트가 프락시에게 어디에 접속하려고 하는지 말해주는 방법을 약간 수정해야 한다. 

<br /><br />

## HTTPS SSL 터널링 프로토콜

클라이언트가 암호화 된 메세지를 프락시 서버에게 보낼 때 생기는 문제를 해결하는 가장 인기있는 방법이다.

1. 클라이언트는 `CONNECT` 확장 메서드를 사용하여 프락시에게 자신이 연결하고자 하는 안전한 호스트와 포트 번호를 말해준다. (평문으로 된 endpoint 전송)
2. 클라이언트와 서버 사이에 데이터가 직접 오갈 수 있는 터널을 만든다.

    - 클라이언트 요청
      
    ![Untitled 8](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/f6baf655-73e4-4289-899e-4daef9248cd1)
    
    - 성공했을 시의 서버 응답
      
    ![Untitled 9](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/095cb4f7-e35a-4593-8646-cd3683eb7b9c)



<br /><br /><br />

---

# 요약

HTTPS 프로토콜을 통해 통신을 암호화하여 보안을 강화한다.

- **HTTPS 프로토콜**
    - HTTPS는 보안 전송 계층을 통해 전송되는 HTTP이다.
    - HTTPS는 HTTP 메세지를 TCP로 보내기 전에, SSL(SSL, TLS) 계층으로 보낸다.

- SSL 계층은 서버와 클라이언트 간의 핸드셰이크를 통해 암호화 알고리즘과 키를 협상한다.
- 서버는 디지털 서명을 사용하여 자신의 신원을 인증하고, 
클라이언트는 서버의 공개키를 사용하여 통신을 암호화한다.
- 대칭키와 공개키 암호화 방식을 혼합하여 사용하는 경우가 일반적이다.
- 디지털 서명, 디지털 인증서를 통해 통신의 무결성과 신뢰성을 보장한다.
- 프락시를 통할 경우 HTTPS 터널링을 통해 클라이언트와 서버 간의 통신을 안전하게 유지할 수 있다.

이를 통해 안전한 HTTP 통신을 위해 서버와 클라이언트 간의 신원 인증, 데이터 암호화, 무결성 보호가 이루어지며, 이러한 보안 요소들이 네트워크 통신을 안전하게 만든다.
