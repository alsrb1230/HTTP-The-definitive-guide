# HTTP Study - 6. Proxy

# 프락시란?

클라이언트와 서버 사이에 위치하여 HTTP 메세지를 정리하는 중개자

웹 서버이기도 하고 웹 클라이언트이기도 하다.

→ 클라이언트의 요청을 받게 되므로. 웹 서버처럼 요청과 커넥션을 적절히 다루고 응답을 돌려줘야 한다.
→ 동시에 요청을 서버로 보내기도 하므로, 요청을 보내고 응답을 받는 HTTP 클라이언트처럼 동작해야 한다.

⇒ 직접 HTTP 프락시를 만든다면, HTTP **클라이언트와 서버 양쪽의 규칙을 모두 준수**해야 함

![Untitled](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/ce167a20-07d8-408a-a10e-1ed80742567b)

<br /><br />

## 개인 프락시 / 공유 프락시

- **개인 프락시** : 하나의 클라이언트만을 위한 프락시
- **공유 프락시** : 여러 클라이언트가 함께 사용하는 프락시

대부분의 프락시들은 공유 프락시의 형태

<br /><br />

## 게이트웨이?

- **프락시** : 같은 프로토콜을 사용하는 둘 이상의 어플리케이션 연결
- **게이트웨이** : 서로 다른 프로토콜을 사용하는 둘 이상을 연결
  - 게이트웨이는 클라이언트와 서버가 서로 다른 프로토콜로 말하더라도,
    서로 간의 트랜잭션을 완료할 수 있도록 해주는 ‘프로토콜 변환기’처럼 동작

![Untitled 1](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/949035e2-250b-4cd9-96ca-aba5907cf278)

- A의 경우, 클라이언트와 서버 둘 다 양쪽에게 HTTP로 말하고 있으므로 HTTP 프락시
- B의 경우, HTTP 프론트엔드, POP 이메일 백엔드를 향하고 있으므로 HTTP/POP 게이트웨이

실질적으로는 프락시와 게이트웨이의 차이점은 모호하다.

- 브라우저와 서버는 다른 버전의 HTTP를 구현하기 떄문에, 프락시 또한 때때로 프로토콜 변환을 하기도 한다.
- 상용 프락시 서버의 경우, SSL 보안 프로토콜, Sockts 방화벽, FTP 접근, 웹 기반 어플리케이션 지원을 위해 게이트웨이 기능을 구현

<br /><br /><br />

# 프락시 사용 이유

보안 개선 / 성능 향상 / 비용 절약 + 모든 HTTP 트래픽 감시 및 수정 가능

### 1. 어린이 필터

![Untitled 2](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/5b389ac0-ec5a-48cd-b2df-6fb188fc922d)

어린이에게 부적절한 사이트의 접근을 강제로 거부하는 필터 프락시 예시

<br />

### 2. 문서 접근 제어

![Untitled 3](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/4b5b787c-f1ce-485a-80e4-164fd59146ac)

회사 내 각기 다른 조직에서 관리되는 다양한 종류, 수많은 웹 서버들에 대한 접근 제어를 중앙 프락시에서 설정 가능

<br />

### 3. 보안 방화벽

![Untitled 4](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/833788f0-d831-4d26-9cae-d422ab052fa4)

특정 조직 안에 들어오거나 나가는 응용 레벨 프로토콜의 흐름을 네트워크의 한 지점에서 통제
바이러스 제거 웹, 이메일 프락시가 사용할 수 있는, 트래픽을 세심히 살펴볼 수 있는 Hook 제공

<br />

### 4. 웹 캐시

![%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-10-25_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11 28 01](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/b7406487-23af-4155-8c08-64577f42043d)

문서의 사본 관리, 요청이 오면 빠르게 제공

<br />

### 5. 대리 프락시

![Untitled 5](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/f97950b5-2598-405b-8ab3-c0405a93ee39)

웹 서버인 것 처럼 위장해 진짜 웹 서버 요청을 받지만, 응답을 내려주는 것이 아닌
요청 받은 콘텐츠의 위치를 찾아내기 위해 다른 서버와 커뮤니케이션 담당 (느린 웹 서버 성능 가속 = 서버 가속기)

<br />

### 6. 콘텐츠 라우터

![Untitled 6](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/abf04236-fb81-4561-a1b9-73c82ac33a96)

인터넷 트래픽 조건과 콘텐츠의 종류에 따라 요청을 특정 웹 서버로 유도

<br />

### 7. 트랜스코더

![Untitled 7](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/4a86f7a4-44a8-4986-8ddb-0d98729bd36b)

콘텐츠를 클라이언트에 전달하기 전에, 본문 포맷팅 가능

- 크기를 줄이기 위해 자신을 거쳐가는 gif 이미지 → jpg 변환
- 이미지 색 강도 줄이기 / 텍스트 파일 압축 / 문서 외국어 변환 가능

<br />

### 8. 익명화 프락시

![Untitled 8](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/6de8840d-5a77-415a-96ba-a97c4f6c6ecb)

HTTP 메세지에서 신원 확인이 가능한 헤더들 삭제 (ip, from, referer, 쿠키, url 세선) = 익명성 보장

<br /><br /><br />

# 프락시의 위치

프락시는 어떻게 사용하느냐에 따라 **어디에든 배치 가능**하다.

<br />

## 프락시 서버가 배치될 수 있는 방법

### 1. 출구(Egpress) 프락시

로컬 네트워크의 출구에 프락시 배치

- 로컬 네트워크 < - > 더 큰 인터넷
- 회사 밖의 악의적인 해커들을 막는 방화벽 제공을 위해 / 인터넷 요금 절약 및 성능 개선을 위해 사용
- 부적절한 콘텐츠 브라우징을 막는 필터링 출구 프락시

<br />

### 2. 접근(입구) 프락시

ISP 접근 지점에 프락시 배치

- 사용자들의 다운로드 속도 개선, 인터넷 대역폭 비용 절감을 위해 사용

> ISP(Internet Service Provider)<br />
> 인터넷에 접속하는 수단을 제공하는 주체

<br />

### 3. 대리 프락시

웹 서버 바로 앞에 위치

- 모든 요청을 처리하는 역할 + 필요할 때만 웹 서버에 자원 요청
- 일반적으로 웹 서버의 이름과 IP 주소로 스스로를 가장 → 모든 요청을 받게 된다.

<br />

### 4. 네트워크 교환 프락시

네트워크 사이 인터넷 피어링 교환 지점에 배치

- 캐시를 이용하여 인터넷 교차로의 혼잡 완화, 트래픽 감시를 위해 사용

<br /><br />

## 프락시 계층

프락시들은 프락시 계층이라고 불리는 연쇄를 구성할 수 있다. (부모와 자식 관계)

- 서버쪽에 가까운 프락시를 부모(인바운드 프락시),<br />
  클라이언트 쪽에 가까운 프락시를 자식(아웃바운드 프락시)라 말한다.

![Untitled 9](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/d449137b-edc7-4555-93e2-a07c69b9461c)

정적 프락시 계층의 예시

<br />

### 프락시 계층 콘텐츠 라우팅

계층은 정적일 수도 동적일 수도 있다.

![Untitled 10](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/67c6b89f-5bac-4543-8b05-2d39e4519954)

동적 프락시 계층의 예시
’접근 프락시’는 상황에 맞게 부모 프락시나 원 서버에게 라우팅

<br />

동적으로 부모를 선택하는 몇가지 예시

1. 부하 균형 : 부모들의 작업량 수준에 근거하여 부모 선택
2. 지리적 인접성 근거 : 원 서버의 지역을 담당하는 부모 선택
3. 프로토콜/타입 라우팅 : URI에 근거하여 라우팅
   (특정 종류의 URI 가지고 있으면, 특별한 프락시 서버로 보내져 처리될 수 있다.)
4. 유료 서비스 가입자 라우팅 : 유료 서비스 구독자들의 URI는 대형 캐시나 성능 개선을 위한 압축 엔진으로 라우팅

동적 라우팅 로직은 제품마다 다르게 구현된다.

- 제품 : 설정 파일, 스크립트 언어, 동적으로 실행 가능한 플러그인 등

<br />

### 프락시의 트래픽 처리 방법

클라이언트 트래픽이 프락시로 가도록 하는 방법

1. 클라이언트 수정
   1. 많은 웹 클라이언트들은 수동, 자동 프락시 설정 기능 지원
2. 네트워크 수정
   1. 스위칭 장치, 라우팅 장치를 통해 HTTP 트래픽을 지켜보다가 가로채어 프락시로 전송
3. DNS 이름공간 수정
   1. DNS 이름 테이블을 수동으로 편집하거나 사용할 적절한 프락시나 서버를 게산해주는 동적 DNS 서버를 사용하여 프락시의 이름 조정 가능
4. 웹 서버 수정
   1. 웹 서버의 리다이렉트 대상을 프락시로 설정

![Untitled 11](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/259ceed1-13ef-4049-ada5-f8fd87ecc749)

<br /><br /><br />

# 클라이언트 프락시 설정

브라우저가 프락시를 설정하는 방법에는 여러가지가 있다.

1. 수동 설정
2. 브라우저 기본 설정
3. 프락시 자동 설정 (PAC)
4. WPAD 프락시 발견

<br /><br />

## 1. 수동 설정

구글 크롬, 마이크로소프트 익스 등 많은 웹 클라이언트가 간편하게 프락시 수동으로 설정 가능

사용 방법은 다르지만 공통적인 로직은 같다.

- 프락시의 호스트와 포트 지정
- ISP는 그들의 요구에 맞춰 미리 설정된 브라우저나 웹 트래픽을 프락시 서버로 리다이렉트하는 맞춤형 운영 체제 구입

아무래도 수동으로 설정해야 하기 때문에 유연한 대처는 불가능하다.

<br /><br />

## 2. 프락시 자동 설정 (PAC)

프락시 설정을 상황에 맞게 계산해주는 작은 자바스크립트 프로그램

PAC 파일의 URI를 브라우저에 설정해야 사용 가능

- 브라우저는 URI로부터 PAC 파일을 가져와 매 접근마다 적절한 프락시 서버를 계산

<br />

### PAC 파일

- `.pac` 확장자
- MIME type: ‘`application/x-ns-proxy-autoconfig`’
- `FindProxyForUrl(url, host)` 함수 정의해야 함
- 예시
  ```jsx
  function FindProxyForURL(url, host) {
    if (url.substring(0, 5) == 'http:') {
      return 'PROXY http-proxy.mydomain.com:8080';
    } else if (url.substring(0, 4) == 'ftp:') {
      return 'PROXY ftp-proxy.mydomain.com:8080';
    } else {
      return 'DIRECT';
    }
  }
  ```

<br /><br />

## 3. WPAD 프락시 발견

WPAD(웹 프락시 자동발견 프로토콜)은 브라우저에게 알맞는 PAC 파일을 자동으로 찾아주는 알고리즘이다.

- PAC URI를 찾기 위해 WPAD를 사용하면
- 주어진 URI에서 PAC 파일을 가져오고 → 실행 → 알아낸 프락시 서버를 이용하여 요청 처리

WPAD는 PAC 파일을 적절하게 가져오기 위해 다음의 기법을 하나씩 시도

- 동적 호스트 발견 규약 (DHCP)
- 서비스 위치 규약 (SLP)
- DNS 잘 알려진 호스트 명
- DNS SRV 레코드
- DNS TXT 레코드 안의 서비스 URI

<br /><br /><br />

# 프락시 요청의 미묘한 특징들

## 1. 프락시 URI는 서버 URI와 다르다.

웹 서버와 웹 프락시의 문법은 서로 같지만 한 가지 예외가 존재한다. = URI가 달라진다.

- 클라이언트가 웹 서버로 요청을 보낼 때
  ```
  GET /index.html HTTP/1.0
  User-Agent: SuperBrowserv1.3
  ```
- 클라이언트가 프락시로 요청을 보낼 때
  ```
  GET http://www.marys-antiques.com/index.html HTTP/1.0
  User-Agent: SuperBrowser v1.3
  ```

기존 클라이언트 : 단일한 서버와 직접 대화

단일 서버는 자신의 호스트 명과 포트번호를 알고 있다!

- 부분 URI 전송

프락시가 도입되고 난 이후 클라이언트 : 프락시와 대화 → 프락시가 목적지 서버와 대화

프락시는 목적지 서버의 이름을 모른다!

- 완전한 URI 전송

<br />

> **가상 호스팅**<br /><br />가상 호스팅에서도 부분 URI를 사용하면, 웹 서버는 그 요청이 접근하고자 하는 웹 사이트의 호스트명을 모른다.<br />→ 호스트와 포트에 대한 정보가 담겨있는 Host 헤더를 요구하는 방법으로 해결

<br /><br />

## 2. 대리(인터셉트) 프락시는 부분 URI를 받는다.

대리 프락시는 클라이언트가 그 존재를 모른다

- 대리 프락시는 원 서버의 호스트 명과 아이피 주소를 사용해 원 서버를 대신
- 부분 URI를 받게 된다. ⇒ 문제 없음

<br /><br />

## 3. 프락시는 프락시 요청과 서버 요청을 전부 다룰 수 있다.

트래픽이 프락시 서버로 리다이렉트 되는데에는 수많은 방법 존재

→ 다목적 프락시 서버는 완전 URI와 부분 URI 방식을 모두 지원해야 한다.

<br /><br />

## 4. 전송 중 URI 변경

사소한 URI 변경이라도, 다운스트림 서버와 상호운용성 문제를 일으킬 수 있으므로 URI 변경은 매우 중요.

따라서 일반적으로 프락시 서버는 가능한 한 관대해야 한다.

- 기본 HTTP 포트를 명시적인 :80으로 변경하는 것
- 잘못 사용된 글자를 → 올바르게 이스케이프 하는 것

⇒ 이처럼 당연한 URI 변경도 문제를 야기할 수 있다.

> 빈 경로를 ‘/’로 고치는 것이 유일한 예외

<br /><br />

## 5. URI 클라이언트 자동확장과 호스트 명 분석

브라우저는 요청 URI를 상황에 따라 다르게 분석

- 프락시가 없다면 URI에 대응하는 IP 주소를 찾는다.
- 호스트명이 발견되면 그에 대응하는 IP 주소들을 연결에 성공할 때까지 시도

만약 호스트명이 발견되지 않는다면, 호스트명의 확장을 제공한다.

- 웹 사이트의 가운데 부분만 입력 (`naver` → `www.naver.com`)
- 해석할 수 없는 URI는 서드파티 사이트로 넘겨 그 곳에서 사용자가 의도했을 만한 URI 예측
- DNS는 사용자가 호스트명의 앞부분만 입력한다면 자동으로 관련 도메인을 검색하도록 설정

![Untitled 12](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/26d12362-3fa0-43d4-b863-4aaf2a539e4f)

명시적인 프락시를 사용할 때의 URI 분석

![Untitled 13](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/c046a448-3123-452c-b6ab-478e043b55b5)

대리 프락시를 사용할 때의 URI 분석

(1) 사용자는 브라우저의 URI 창에 ‘`oreilly`’ 타이핑

(2) a에서 브라우저는 ‘`oreilly`’를 찾지만 → b 에서 찾을 수 없다 응답 반환

(3) a에서 브라우저는 ‘`oreilly`’를 ‘`www.oreilly.com`’으로 **확장**하여 전송
→ b에서 실제 서버 주소 응답 반환

(4) 대리 프락시에 의해 a 요청 종료 (but, 클라이언트는 그걸 모른다.) → b 응답 반환

(5) 대리 프락시가 실제 원 서버와 연결할 준비가 되어 연결이 성립 → 하지만 원 서버는 죽어있다.

- 이런 경우에는 호스트 헤더에 들어있는 호스트 명을 다시 분석하든, IP 주소에 대한 역방향 DNS 룩업을 해서든 다른 IP 주소 시도

<br /><br /><br />

---

### 6.7 메세지 추적부터는

혜선님께 토스하겠습니다. 😉

![Untitled 14](https://github.com/musinsa-global-developer-study/HTTP-The-definitive-guide/assets/72294509/03429507-ee7e-4488-ab7b-5132fd07bb42)
